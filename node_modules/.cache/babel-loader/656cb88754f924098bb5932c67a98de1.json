{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n};\n\nimport { useMemo, useState, useEffect, useRef, useCallback } from 'react';\nimport { useSelector } from 'react-redux';\nimport isEqual from 'lodash/isEqual';\nimport difference from 'lodash/difference';\nimport { useGetMany } from '../../dataProvider';\nimport { useForm } from 'react-final-form';\nimport useGetMatching from '../../dataProvider/useGetMatching';\nimport { useTranslate } from '../../i18n';\nimport { getStatusForArrayInput as getDataStatus } from './referenceDataStatus';\nimport { useResourceContext } from '../../core';\nimport { usePaginationState, useSortState } from '..';\nimport { indexById, removeEmpty, useSafeSetState } from '../../util';\n/**\n * Prepare data for the ReferenceArrayInput components\n *\n * @example\n *\n * const { choices, error, loaded, loading } = useReferenceArrayInputController({\n *      basePath: 'resource';\n *      record: { referenceIds: ['id1', 'id2']};\n *      reference: 'reference';\n *      resource: 'resource';\n *      source: 'referenceIds';\n * });\n *\n * @param {Object} props\n * @param {string} props.basePath basepath to current resource\n * @param {Object} props.record The current resource record\n * @param {string} props.reference The linked resource name\n * @param {string} props.resource The current resource name\n * @param {string} props.source The key of the linked resource identifier\n *\n * @param {Props} props\n *\n * @return {Object} controllerProps Fetched data and callbacks for the ReferenceArrayInput components\n */\n\nexport var useReferenceArrayInputController = function useReferenceArrayInputController(props) {\n  var defaultFilter = props.filter,\n      _a = props.filterToQuery,\n      filterToQuery = _a === void 0 ? defaultFilterToQuery : _a,\n      input = props.input,\n      _b = props.page,\n      initialPage = _b === void 0 ? 1 : _b,\n      _c = props.perPage,\n      initialPerPage = _c === void 0 ? 25 : _c,\n      _d = props.sort,\n      initialSort = _d === void 0 ? {\n    field: 'id',\n    order: 'DESC'\n  } : _d,\n      options = props.options,\n      reference = props.reference,\n      source = props.source;\n  var resource = useResourceContext(props);\n  var translate = useTranslate(); // We store the current input value in a ref so that we are able to fetch\n  // only the missing references when the input value changes\n\n  var inputValue = useRef(input.value);\n\n  var _e = useState(input.value),\n      idsToFetch = _e[0],\n      setIdsToFetch = _e[1];\n\n  var _f = useState([]),\n      idsToGetFromStore = _f[0],\n      setIdsToGetFromStore = _f[1];\n\n  var referenceRecordsFromStore = useSelector(function (state) {\n    return idsToGetFromStore.map(function (id) {\n      return state.admin.resources[reference].data[id];\n    });\n  }); // optimization: we fetch selected items only once. When the user selects more items,\n  // as we already have the past selected items in the store, we don't fetch them.\n\n  useEffect(function () {\n    // Only fetch new ids\n    var newIdsToFetch = difference(input.value, inputValue.current); // Only get from store ids selected and already fetched\n\n    var newIdsToGetFromStore = difference(input.value, newIdsToFetch);\n    /*\n        input.value (current)\n            +------------------------+\n            | ********************** |\n            | ********************** |  inputValue.current (old)\n            | ********** +-----------------------+\n            | ********** | ooooooooo |           |\n            | ********** | ooooooooo |           |\n            | ********** | ooooooooo |           |\n            | ********** | ooooooooo |           |\n            +---|--------|------|----+           |\n                |        |      |                |\n                |        |      |                |\n                |        +------|----------------+\n                |               |\n        newIdsToFetch    newIdsToGetFromStore\n    */\n    // Change states each time input values changes to avoid keeping previous values no more selected\n\n    if (!isEqual(idsToFetch, newIdsToFetch)) {\n      setIdsToFetch(newIdsToFetch);\n    }\n\n    if (!isEqual(idsToGetFromStore, newIdsToGetFromStore)) {\n      setIdsToGetFromStore(newIdsToGetFromStore);\n    }\n\n    inputValue.current = input.value;\n  }, [idsToFetch, idsToGetFromStore, input.value, setIdsToFetch, setIdsToGetFromStore]); // pagination logic\n\n  var _g = usePaginationState({\n    page: initialPage,\n    perPage: initialPerPage\n  }),\n      page = _g.page,\n      setPage = _g.setPage,\n      perPage = _g.perPage,\n      setPerPage = _g.setPerPage,\n      pagination = _g.pagination,\n      setPagination = _g.setPagination;\n\n  var form = useForm();\n  var onSelect = useCallback(function (newIds) {\n    var newValue = new Set(input.value);\n    newIds.forEach(function (newId) {\n      newValue.add(newId);\n    });\n    form.change(input.name, Array.from(newValue));\n  }, [form, input.name, input.value]);\n  var onUnselectItems = useCallback(function () {\n    form.change(input.name, []);\n  }, [form, input.name]);\n  var onToggleItem = useCallback(function (id) {\n    if (input.value.some(function (selectedId) {\n      return selectedId === id;\n    })) {\n      form.change(input.name, input.value.filter(function (selectedId) {\n        return selectedId !== id;\n      }));\n    } else {\n      form.change(input.name, __spreadArrays(input.value, [id]));\n    }\n  }, [form, input.name, input.value]); // sort logic\n\n  var sortRef = useRef(initialSort);\n\n  var _h = useSortState(initialSort),\n      sort = _h.sort,\n      setSort = _h.setSort; // ReferenceArrayInput.setSort had a different signature than the one from ListContext.\n  // In order to not break backward compatibility, we added this temporary setSortForList in the\n  // ReferenceArrayInputContext\n\n\n  var setSortForList = useCallback(function (field, order) {\n    if (order === void 0) {\n      order = 'ASC';\n    }\n\n    setSort({\n      field: field,\n      order: order\n    });\n    setPage(1);\n  }, [setPage, setSort]); // Ensure sort can be updated through props too, not just by using the setSort function\n\n  useEffect(function () {\n    if (!isEqual(initialSort, sortRef.current)) {\n      setSort(initialSort);\n    }\n  }, [setSort, initialSort]); // Ensure pagination can be updated through props too, not just by using the setPagination function\n\n  var paginationRef = useRef({\n    initialPage: initialPage,\n    initialPerPage: initialPerPage\n  });\n  useEffect(function () {\n    if (!isEqual({\n      initialPage: initialPage,\n      initialPerPage: initialPerPage\n    }, paginationRef.current)) {\n      setPagination({\n        page: initialPage,\n        perPage: initialPerPage\n      });\n    }\n  }, [setPagination, initialPage, initialPerPage]); // filter logic\n\n  var _j = useState(''),\n      queryFilter = _j[0],\n      setFilter = _j[1];\n\n  var filterRef = useRef(defaultFilter);\n\n  var _k = useSafeSetState({}),\n      displayedFilters = _k[0],\n      setDisplayedFilters = _k[1];\n\n  var _l = useSafeSetState(defaultFilter),\n      filterValues = _l[0],\n      setFilterValues = _l[1];\n\n  var hideFilter = useCallback(function (filterName) {\n    setDisplayedFilters(function (previousState) {\n      var _a = previousState,\n          _b = filterName,\n          _ = _a[_b],\n          newState = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n      return newState;\n    });\n    setFilterValues(function (previousState) {\n      var _a = previousState,\n          _b = filterName,\n          _ = _a[_b],\n          newState = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\n\n      return newState;\n    });\n  }, [setDisplayedFilters, setFilterValues]);\n  var showFilter = useCallback(function (filterName, defaultValue) {\n    setDisplayedFilters(function (previousState) {\n      var _a;\n\n      return __assign(__assign({}, previousState), (_a = {}, _a[filterName] = true, _a));\n    });\n    setFilterValues(function (previousState) {\n      var _a;\n\n      return __assign(__assign({}, previousState), (_a = {}, _a[filterName] = defaultValue, _a));\n    });\n  }, [setDisplayedFilters, setFilterValues]);\n  var setFilters = useCallback(function (filters, displayedFilters) {\n    setFilterValues(removeEmpty(filters));\n    setDisplayedFilters(displayedFilters);\n    setPage(1);\n  }, [setDisplayedFilters, setFilterValues, setPage]); // handle filter prop change\n\n  useEffect(function () {\n    if (!isEqual(defaultFilter, filterRef.current)) {\n      filterRef.current = defaultFilter;\n      setFilterValues(defaultFilter);\n    }\n  }); // Merge the user filters with the default ones\n\n  var finalFilter = useMemo(function () {\n    return __assign(__assign({}, defaultFilter), filterToQuery(queryFilter));\n  }, [queryFilter, defaultFilter, filterToQuery]);\n\n  var _m = useGetMany(reference, idsToFetch || []),\n      referenceRecordsFetched = _m.data,\n      loaded = _m.loaded,\n      refetchGetMany = _m.refetch;\n\n  var referenceRecords = referenceRecordsFetched ? referenceRecordsFetched.concat(referenceRecordsFromStore) : referenceRecordsFromStore; // filter out not found references - happens when the dataProvider doesn't guarantee referential integrity\n\n  var finalReferenceRecords = referenceRecords.filter(Boolean);\n\n  var _o = useGetMatching(reference, pagination, sort, finalFilter, source, resource, options),\n      matchingReferences = _o.data,\n      matchingReferencesIds = _o.ids,\n      total = _o.total,\n      refetchGetMatching = _o.refetch; // We merge the currently selected records with the matching ones, otherwise\n  // the component displaying the currently selected records may fail\n\n\n  var finalMatchingReferences = matchingReferences && matchingReferences.length > 0 ? mergeReferences(matchingReferences, finalReferenceRecords) : finalReferenceRecords.length > 0 ? finalReferenceRecords : matchingReferences;\n  var dataStatus = getDataStatus({\n    input: input,\n    matchingReferences: finalMatchingReferences,\n    referenceRecords: finalReferenceRecords,\n    translate: translate\n  });\n  var refetch = useCallback(function () {\n    refetchGetMany();\n    refetchGetMatching();\n  }, [refetchGetMany, refetchGetMatching]);\n  return {\n    basePath: props.basePath || \"/\" + resource,\n    choices: dataStatus.choices,\n    currentSort: sort,\n    // For the ListContext, we don't want to always display the selected items first.\n    // Indeed it wouldn't work well regarding sorting and pagination\n    data: matchingReferences && matchingReferences.length > 0 ? indexById(matchingReferences) : {},\n    displayedFilters: displayedFilters,\n    error: dataStatus.error,\n    filterValues: filterValues,\n    hasCreate: false,\n    hideFilter: hideFilter,\n    // For the ListContext, we don't want to always display the selected items first.\n    // Indeed it wouldn't work well regarding sorting and pagination\n    ids: matchingReferencesIds || [],\n    loaded: loaded,\n    loading: dataStatus.waiting,\n    onSelect: onSelect,\n    onToggleItem: onToggleItem,\n    onUnselectItems: onUnselectItems,\n    page: page,\n    perPage: perPage,\n    refetch: refetch,\n    resource: resource,\n    selectedIds: input.value,\n    setFilter: setFilter,\n    setFilters: setFilters,\n    setPage: setPage,\n    setPagination: setPagination,\n    setPerPage: setPerPage,\n    setSort: setSort,\n    setSortForList: setSortForList,\n    showFilter: showFilter,\n    warning: dataStatus.warning,\n    total: total\n  };\n}; // concatenate and deduplicate two lists of records\n\nvar mergeReferences = function mergeReferences(ref1, ref2) {\n  var res = __spreadArrays(ref1);\n\n  var ids = ref1.map(function (ref) {\n    return ref.id;\n  });\n  ref2.forEach(function (ref) {\n    if (!ids.includes(ref.id)) {\n      ids.push(ref.id);\n      res.push(ref);\n    }\n  });\n  return res;\n};\n\nvar defaultFilterToQuery = function defaultFilterToQuery(searchText) {\n  return {\n    q: searchText\n  };\n};","map":null,"metadata":{},"sourceType":"module"}