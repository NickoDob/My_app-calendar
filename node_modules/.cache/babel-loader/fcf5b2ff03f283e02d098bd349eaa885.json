{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { useContext, useMemo } from 'react';\nimport { useDispatch, useSelector, useStore } from 'react-redux';\nimport DataProviderContext from './DataProviderContext';\nimport defaultDataProvider from './defaultDataProvider';\nimport useLogoutIfAccessDenied from '../auth/useLogoutIfAccessDenied';\nimport { getDataProviderCallArguments } from './getDataProviderCallArguments';\nimport { doQuery, stackCall, stackOptimisticCall, getRemainingStackedCalls } from './performQuery';\n/**\r\n * Hook for getting a dataProvider\r\n *\r\n * Gets a dataProvider object, which behaves just like the real dataProvider\r\n * (same methods returning a Promise). But it's actually a Proxy object, which\r\n * dispatches Redux actions along the process. The benefit is that react-admin\r\n * tracks the loading state when using this hook, and stores results in the\r\n * Redux store for future use.\r\n *\r\n * In addition to the 2 usual parameters of the dataProvider methods (resource,\r\n * payload), the Proxy supports a third parameter for every call. It's an\r\n * object literal which may contain side effects, or make the action optimistic\r\n * (with mutationMode: optimistic) or undoable (with mutationMode: undoable).\r\n *\r\n * @return dataProvider\r\n *\r\n * @example Basic usage\r\n *\r\n * import * as React from 'react';\r\n * import { useState } from 'react';\r\n * import { useDataProvider } from 'react-admin';\r\n *\r\n * const PostList = () => {\r\n *      const [posts, setPosts] = useState([])\r\n *      const dataProvider = useDataProvider();\r\n *      useEffect(() => {\r\n *          dataProvider.getList('posts', { filter: { status: 'pending' }})\r\n *            .then(({ data }) => setPosts(data));\r\n *      }, [])\r\n *\r\n *      return (\r\n *          <Fragment>\r\n *              {posts.map((post, key) => <PostDetail post={post} key={key} />)}\r\n *          </Fragment>\r\n *     );\r\n * }\r\n *\r\n * @example Handling all states (loading, error, success)\r\n *\r\n * import { useState, useEffect } from 'react';\r\n * import { useDataProvider } from 'react-admin';\r\n *\r\n * const UserProfile = ({ userId }) => {\r\n *     const dataProvider = useDataProvider();\r\n *     const [user, setUser] = useState();\r\n *     const [loading, setLoading] = useState(true);\r\n *     const [error, setError] = useState();\r\n *     useEffect(() => {\r\n *         dataProvider.getOne('users', { id: userId })\r\n *             .then(({ data }) => {\r\n *                 setUser(data);\r\n *                 setLoading(false);\r\n *             })\r\n *             .catch(error => {\r\n *                 setError(error);\r\n *                 setLoading(false);\r\n *             })\r\n *     }, []);\r\n *\r\n *     if (loading) return <Loading />;\r\n *     if (error) return <Error />\r\n *     if (!user) return null;\r\n *\r\n *     return (\r\n *         <ul>\r\n *             <li>Name: {user.name}</li>\r\n *             <li>Email: {user.email}</li>\r\n *         </ul>\r\n *     )\r\n * }\r\n *\r\n * @example Action customization\r\n *\r\n * dataProvider.getOne('users', { id: 123 });\r\n * // will dispatch the following actions:\r\n * // - CUSTOM_FETCH\r\n * // - CUSTOM_FETCH_LOADING\r\n * // - FETCH_START\r\n * // - CUSTOM_FETCH_SUCCESS\r\n * // - FETCH_END\r\n *\r\n * dataProvider.getOne('users', { id: 123 }, { action: CRUD_GET_ONE });\r\n * // will dispatch the following actions:\r\n * // - CRUD_GET_ONE\r\n * // - CRUD_GET_ONE_LOADING\r\n * // - FETCH_START\r\n * // - CRUD_GET_ONE_SUCCESS\r\n * // - FETCH_END\r\n */\n\nvar useDataProvider = function useDataProvider() {\n  var dispatch = useDispatch();\n  var dataProvider = useContext(DataProviderContext) || defaultDataProvider; // optimistic mode can be triggered by a previous optimistic or undoable query\n\n  var isOptimistic = useSelector(function (state) {\n    return state.admin.ui.optimistic;\n  });\n  var store = useStore();\n  var logoutIfAccessDenied = useLogoutIfAccessDenied();\n  var dataProviderProxy = useMemo(function () {\n    return new Proxy(dataProvider, {\n      get: function get(target, name) {\n        if (typeof name === 'symbol') {\n          return;\n        }\n\n        return function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          var _a = getDataProviderCallArguments(args),\n              resource = _a.resource,\n              payload = _a.payload,\n              allArguments = _a.allArguments,\n              options = _a.options;\n\n          var type = name.toString();\n\n          var _b = options || {},\n              _c = _b.action,\n              action = _c === void 0 ? 'CUSTOM_FETCH' : _c,\n              _d = _b.undoable,\n              undoable = _d === void 0 ? false : _d,\n              _e = _b.onSuccess,\n              onSuccess = _e === void 0 ? undefined : _e,\n              _f = _b.onFailure,\n              onFailure = _f === void 0 ? undefined : _f,\n              _g = _b.mutationMode,\n              mutationMode = _g === void 0 ? undoable ? 'undoable' : 'pessimistic' : _g,\n              _h = _b.enabled,\n              enabled = _h === void 0 ? true : _h,\n              rest = __rest(_b, [\"action\", \"undoable\", \"onSuccess\", \"onFailure\", \"mutationMode\", \"enabled\"]);\n\n          if (typeof dataProvider[type] !== 'function') {\n            throw new Error(\"Unknown dataProvider function: \" + type);\n          }\n\n          if (onSuccess && typeof onSuccess !== 'function') {\n            throw new Error('The onSuccess option must be a function');\n          }\n\n          if (onFailure && typeof onFailure !== 'function') {\n            throw new Error('The onFailure option must be a function');\n          }\n\n          if (mutationMode === 'undoable' && !onSuccess) {\n            throw new Error('You must pass an onSuccess callback calling notify() to use the undoable mode');\n          }\n\n          if (typeof enabled !== 'boolean') {\n            throw new Error('The enabled option must be a boolean');\n          }\n\n          if (enabled === false) {\n            return Promise.resolve({});\n          }\n\n          var params = {\n            resource: resource,\n            type: type,\n            payload: payload,\n            action: action,\n            onFailure: onFailure,\n            onSuccess: onSuccess,\n            rest: rest,\n            mutationMode: mutationMode,\n            // these ones are passed down because of the rules of hooks\n            dataProvider: dataProvider,\n            store: store,\n            dispatch: dispatch,\n            logoutIfAccessDenied: logoutIfAccessDenied,\n            allArguments: allArguments\n          };\n\n          if (isOptimistic) {\n            // When in optimistic mode, fetch calls aren't executed\n            // right away. Instead, they are are stacked, to be\n            // executed once the dataProvider leaves optimistic mode.\n            // In the meantime, the admin uses data from the store.\n            if (mutationMode === 'undoable' || mutationMode === 'optimistic') {\n              // optimistic and undoable calls are added to a\n              // specific stack, as they must be replayed first\n              stackOptimisticCall(params);\n            } else {\n              // pessimistic calls are added to the regular stack\n              // and will be replayed last\n              stackCall(params);\n            } // Return a Promise that only resolves when the optimistic call was made\n            // otherwise hooks like useQueryWithStore will return loaded = true\n            // before the content actually reaches the Redux store.\n            // But as we can't determine when this particular query was finished,\n            // the Promise resolves only when *all* optimistic queries are done.\n\n\n            return waitFor(function () {\n              return getRemainingStackedCalls() === 0;\n            });\n          } else {\n            return doQuery(params);\n          }\n        };\n      }\n    });\n  }, [dataProvider, dispatch, isOptimistic, logoutIfAccessDenied, store]);\n  return dataProviderProxy;\n}; // get a Promise that resolves after a delay in milliseconds\n\n\nvar later = function later(delay) {\n  if (delay === void 0) {\n    delay = 100;\n  }\n\n  return new Promise(function (resolve) {\n    setTimeout(resolve, delay);\n  });\n}; // get a Promise that resolves once a condition is satisfied\n\n\nvar waitFor = function waitFor(condition) {\n  return new Promise(function (resolve) {\n    return condition() ? resolve() : later().then(function () {\n      return waitFor(condition).then(function () {\n        return resolve();\n      });\n    });\n  });\n};\n\nexport default useDataProvider;","map":null,"metadata":{},"sourceType":"module"}