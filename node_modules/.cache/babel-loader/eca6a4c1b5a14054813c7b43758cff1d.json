{"ast":null,"code":"import lodashMemoize from 'lodash/memoize';\n/* eslint-disable no-underscore-dangle */\n\n/* @link http://stackoverflow.com/questions/46155/validate-email-address-in-javascript */\n\nvar EMAIL_REGEX = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/; // eslint-disable-line no-useless-escape\n\nvar isEmpty = function isEmpty(value) {\n  return typeof value === 'undefined' || value === null || value === '' || Array.isArray(value) && value.length === 0;\n}; // type predicate, see https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates\n\n\nfunction isValidationErrorMessageWithArgs(error) {\n  return error.hasOwnProperty('message');\n}\n\nvar getMessage = function getMessage(message, messageArgs, value, values) {\n  return typeof message === 'function' ? message({\n    args: messageArgs,\n    value: value,\n    values: values\n  }) : messageArgs ? {\n    message: message,\n    args: messageArgs\n  } : message;\n}; // If we define validation functions directly in JSX, it will\n// result in a new function at every render, and then trigger infinite re-render.\n// Hence, we memoize every built-in validator to prevent a \"Maximum call stack\" error.\n\n\nvar memoize = function memoize(fn) {\n  return lodashMemoize(fn, function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    return JSON.stringify(args);\n  });\n};\n\nvar isFunction = function isFunction(value) {\n  return typeof value === 'function';\n};\n\nexport var combine2Validators = function combine2Validators(validator1, validator2) {\n  return function (value, values, meta) {\n    var result1 = validator1(value, values, meta);\n\n    if (!result1) {\n      return validator2(value, values, meta);\n    }\n\n    if (typeof result1 === 'string' || isValidationErrorMessageWithArgs(result1)) {\n      return result1;\n    }\n\n    return result1.then(function (resolvedResult1) {\n      if (!resolvedResult1) {\n        return validator2(value, values, meta);\n      }\n\n      return resolvedResult1;\n    });\n  };\n}; // Compose multiple validators into a single one for use with final-form\n\nexport var composeValidators = function composeValidators() {\n  var validators = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    validators[_i] = arguments[_i];\n  }\n\n  var allValidators = (Array.isArray(validators[0]) ? validators[0] : validators).filter(isFunction);\n  return allValidators.reduce(combine2Validators, function () {\n    return null;\n  });\n}; // Compose multiple validators into a single one for use with final-form\n\nexport var composeSyncValidators = function composeSyncValidators() {\n  var validators = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    validators[_i] = arguments[_i];\n  }\n\n  return function (value, values, meta) {\n    var allValidators = (Array.isArray(validators[0]) ? validators[0] : validators).filter(isFunction);\n\n    for (var _i = 0, allValidators_1 = allValidators; _i < allValidators_1.length; _i++) {\n      var validator = allValidators_1[_i];\n      var error = validator(value, values, meta);\n\n      if (error) {\n        return error;\n      }\n    }\n  };\n};\n/**\r\n * Required validator\r\n *\r\n * Returns an error if the value is null, undefined, or empty\r\n *\r\n * @param {string|Function} message\r\n *\r\n * @example\r\n *\r\n * const titleValidators = [required('The title is required')];\r\n * <TextInput name=\"title\" validate={titleValidators} />\r\n */\n\nexport var required = memoize(function (message) {\n  if (message === void 0) {\n    message = 'ra.validation.required';\n  }\n\n  return Object.assign(function (value, values) {\n    return isEmpty(value) ? getMessage(message, undefined, value, values) : undefined;\n  }, {\n    isRequired: true\n  });\n});\n/**\r\n * Minimum length validator\r\n *\r\n * Returns an error if the value has a length less than the parameter\r\n *\r\n * @param {integer} min\r\n * @param {string|Function} message\r\n *\r\n * @example\r\n *\r\n * const passwordValidators = [minLength(10, 'Should be at least 10 characters')];\r\n * <TextInput type=\"password\" name=\"password\" validate={passwordValidators} />\r\n */\n\nexport var minLength = memoize(function (min, message) {\n  if (message === void 0) {\n    message = 'ra.validation.minLength';\n  }\n\n  return function (value, values) {\n    return !isEmpty(value) && value.length < min ? getMessage(message, {\n      min: min\n    }, value, values) : undefined;\n  };\n});\n/**\r\n * Maximum length validator\r\n *\r\n * Returns an error if the value has a length higher than the parameter\r\n *\r\n * @param {integer} max\r\n * @param {string|Function} message\r\n *\r\n * @example\r\n *\r\n * const nameValidators = [maxLength(10, 'Should be at most 10 characters')];\r\n * <TextInput name=\"name\" validate={nameValidators} />\r\n */\n\nexport var maxLength = memoize(function (max, message) {\n  if (message === void 0) {\n    message = 'ra.validation.maxLength';\n  }\n\n  return function (value, values) {\n    return !isEmpty(value) && value.length > max ? getMessage(message, {\n      max: max\n    }, value, values) : undefined;\n  };\n});\n/**\r\n * Minimum validator\r\n *\r\n * Returns an error if the value is less than the parameter\r\n *\r\n * @param {integer} min\r\n * @param {string|Function} message\r\n *\r\n * @example\r\n *\r\n * const fooValidators = [minValue(5, 'Should be more than 5')];\r\n * <NumberInput name=\"foo\" validate={fooValidators} />\r\n */\n\nexport var minValue = memoize(function (min, message) {\n  if (message === void 0) {\n    message = 'ra.validation.minValue';\n  }\n\n  return function (value, values) {\n    return !isEmpty(value) && value < min ? getMessage(message, {\n      min: min\n    }, value, values) : undefined;\n  };\n});\n/**\r\n * Maximum validator\r\n *\r\n * Returns an error if the value is higher than the parameter\r\n *\r\n * @param {integer} max\r\n * @param {string|Function} message\r\n *\r\n * @example\r\n *\r\n * const fooValidators = [maxValue(10, 'Should be less than 10')];\r\n * <NumberInput name=\"foo\" validate={fooValidators} />\r\n */\n\nexport var maxValue = memoize(function (max, message) {\n  if (message === void 0) {\n    message = 'ra.validation.maxValue';\n  }\n\n  return function (value, values) {\n    return !isEmpty(value) && value > max ? getMessage(message, {\n      max: max\n    }, value, values) : undefined;\n  };\n});\n/**\r\n * Number validator\r\n *\r\n * Returns an error if the value is not a number\r\n *\r\n * @param {string|Function} message\r\n *\r\n * @example\r\n *\r\n * const ageValidators = [number('Must be a number')];\r\n * <TextInput name=\"age\" validate={ageValidators} />\r\n */\n\nexport var number = memoize(function (message) {\n  if (message === void 0) {\n    message = 'ra.validation.number';\n  }\n\n  return function (value, values) {\n    return !isEmpty(value) && isNaN(Number(value)) ? getMessage(message, undefined, value, values) : undefined;\n  };\n});\n/**\r\n * Regular expression validator\r\n *\r\n * Returns an error if the value does not match the pattern given as parameter\r\n *\r\n * @param {RegExp} pattern\r\n * @param {string|Function} message\r\n *\r\n * @example\r\n *\r\n * const zipValidators = [regex(/^\\d{5}(?:[-\\s]\\d{4})?$/, 'Must be a zip code')];\r\n * <TextInput name=\"zip\" validate={zipValidators} />\r\n */\n\nexport var regex = lodashMemoize(function (pattern, message) {\n  if (message === void 0) {\n    message = 'ra.validation.regex';\n  }\n\n  return function (value, values) {\n    return !isEmpty(value) && typeof value === 'string' && !pattern.test(value) ? getMessage(message, {\n      pattern: pattern\n    }, value, values) : undefined;\n  };\n}, function (pattern, message) {\n  return pattern.toString() + message;\n});\n/**\r\n * Email validator\r\n *\r\n * Returns an error if the value is not a valid email\r\n *\r\n * @param {string|Function} message\r\n *\r\n * @example\r\n *\r\n * const emailValidators = [email('Must be an email')];\r\n * <TextInput name=\"email\" validate={emailValidators} />\r\n */\n\nexport var email = memoize(function (message) {\n  if (message === void 0) {\n    message = 'ra.validation.email';\n  }\n\n  return regex(EMAIL_REGEX, message);\n});\n\nvar oneOfTypeMessage = function oneOfTypeMessage(_a) {\n  var args = _a.args;\n  return {\n    message: 'ra.validation.oneOf',\n    args: args\n  };\n};\n/**\r\n * Choices validator\r\n *\r\n * Returns an error if the value is not among the list passed as parameter\r\n *\r\n * @param {array} list\r\n * @param {string|Function} message\r\n *\r\n * @example\r\n *\r\n * const genderValidators = [choices(['male', 'female'], 'Must be either Male or Female')];\r\n * <TextInput name=\"gender\" validate={genderValidators} />\r\n */\n\n\nexport var choices = memoize(function (list, message) {\n  if (message === void 0) {\n    message = oneOfTypeMessage;\n  }\n\n  return function (value, values) {\n    return !isEmpty(value) && list.indexOf(value) === -1 ? getMessage(message, {\n      list: list\n    }, value, values) : undefined;\n  };\n});","map":null,"metadata":{},"sourceType":"module"}