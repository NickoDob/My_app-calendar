{"ast":null,"code":"import { useCallback } from 'react';\nimport { useDispatch } from 'react-redux';\nimport useAuthProvider, { defaultAuthParams } from './useAuthProvider';\nimport { clearState } from '../actions/clearActions';\nimport { useHistory } from 'react-router-dom';\n/**\r\n * Get a callback for calling the authProvider.logout() method,\r\n * redirect to the login page, and clear the Redux state.\r\n *\r\n * @see useAuthProvider\r\n *\r\n * @returns {Function} logout callback\r\n *\r\n * @example\r\n *\r\n * import { useLogout } from 'react-admin';\r\n *\r\n * const LogoutButton = () => {\r\n *     const logout = useLogout();\r\n *     const handleClick = () => logout();\r\n *     return <button onClick={handleClick}>Logout</button>;\r\n * }\r\n */\n\nvar useLogout = function useLogout() {\n  var authProvider = useAuthProvider();\n  var dispatch = useDispatch();\n  /**\r\n   * We need the current location to pass in the router state\r\n   * so that the login hook knows where to redirect to as next route after login.\r\n   *\r\n   * But if we used useLocation to get it, the logout function\r\n   * would be rebuilt each time the user changes location. Consequently, that\r\n   * would force a rerender of all components using this hook upon navigation\r\n   * (CoreAdminRouter for example).\r\n   *\r\n   * To avoid that, we read the location directly from history which is mutable.\r\n   * See: https://reacttraining.com/react-router/web/api/history/history-is-mutable\r\n   */\n\n  var history = useHistory();\n  var logout = useCallback(function (params, redirectTo, redirectToCurrentLocationAfterLogin) {\n    if (params === void 0) {\n      params = {};\n    }\n\n    if (redirectTo === void 0) {\n      redirectTo = defaultAuthParams.loginUrl;\n    }\n\n    if (redirectToCurrentLocationAfterLogin === void 0) {\n      redirectToCurrentLocationAfterLogin = true;\n    }\n\n    return authProvider.logout(params).then(function (redirectToFromProvider) {\n      dispatch(clearState());\n\n      if (redirectToFromProvider === false) {\n        // do not redirect\n        return;\n      } // redirectTo can contain a query string, e.g. '/login?foo=bar'\n      // we must split the redirectTo to pass a structured location to history.push()\n\n\n      var redirectToParts = (redirectToFromProvider || redirectTo).split('?');\n      var newLocation = {\n        pathname: redirectToParts[0]\n      };\n\n      if (redirectToCurrentLocationAfterLogin && history.location && history.location.pathname) {\n        newLocation.state = {\n          nextPathname: history.location.pathname,\n          nextSearch: history.location.search\n        };\n      }\n\n      if (redirectToParts[1]) {\n        newLocation.search = redirectToParts[1];\n      }\n\n      history.push(newLocation);\n      return redirectToFromProvider;\n    });\n  }, [authProvider, history, dispatch]);\n  var logoutWithoutProvider = useCallback(function (_) {\n    history.push({\n      pathname: defaultAuthParams.loginUrl,\n      state: {\n        nextPathname: history.location && history.location.pathname\n      }\n    });\n    dispatch(clearState());\n    return Promise.resolve();\n  }, [dispatch, history]);\n  return authProvider ? logout : logoutWithoutProvider;\n};\n\nexport default useLogout;","map":null,"metadata":{},"sourceType":"module"}