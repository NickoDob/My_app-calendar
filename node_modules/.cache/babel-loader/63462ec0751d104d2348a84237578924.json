{"ast":null,"code":"/**\r\n * Fork of the https://github.com/ignatevdev/final-form-submit-errors\r\n *\r\n * In react-admin, errors might be objects with `message` and `args` properties which\r\n * are used for translation.\r\n * The original final-form-submit-errors mutator was considering those errors as form\r\n * nested field like `name.message` and `name.args`.\r\n * This version detects those objects.\r\n */\nexport function resetSubmitErrors(_a, state, _b) {\n  var _c = _a[0],\n      prev = _c.prev,\n      current = _c.current;\n  var getIn = _b.getIn,\n      setIn = _b.setIn; // Reset the general submit error on any value change\n\n  if (state.formState.submitError) {\n    delete state.formState.submitError;\n  }\n\n  if (!isObjectEmpty(state.formState.submitErrors)) {\n    // Flatten nested errors object for easier comparison\n    var flatErrors = flatten(state.formState.submitErrors);\n    var changed_1 = []; // Iterate over each error\n\n    Object.keys(flatErrors).forEach(function (key) {\n      // Compare the value for the error field path\n      if (getIn(prev, key) !== getIn(current, key)) {\n        changed_1.push(key);\n      }\n    }); // Reset the error on value change\n\n    if (changed_1.length) {\n      var newErrors_1 = state.formState.submitErrors;\n      changed_1.forEach(function (key) {\n        newErrors_1 = setIn(newErrors_1, key, null);\n      }); // Clear submit errors from empty objects and arrays\n\n      var cleanErrors = clean(newErrors_1);\n      state.formState.submitErrors = cleanErrors;\n    }\n  }\n}\nexport function clean(obj) {\n  var newObj = Array.isArray(obj) ? [] : {};\n  Object.keys(obj).forEach(function (key) {\n    if (obj[key] && typeof obj[key] === 'object') {\n      var newVal = clean(obj[key]);\n\n      if (!isObjectEmpty(newVal) && newVal.length !== 0) {\n        newObj[key] = newVal;\n      }\n    } else if (obj[key] !== null) {\n      newObj[key] = obj[key];\n    }\n  });\n  return newObj;\n}\nexport function flatten(obj) {\n  var toReturn = {};\n\n  for (var i in obj) {\n    if (!obj.hasOwnProperty(i)) {\n      continue;\n    }\n\n    if (typeof obj[i] === 'object' && obj[i] !== null && !isValidationError(obj[i])) {\n      var flatObject = flatten(obj[i]);\n\n      for (var x in flatObject) {\n        if (!flatObject.hasOwnProperty(x)) {\n          continue;\n        } // Make a bracket array notation like some[1].array[0]\n\n\n        var key = (i + \".\" + x).split('.').reduce(function (str, value) {\n          if (/^\\[\\d\\]/.test(value)) {\n            return \"\" + str + value;\n          }\n\n          if (!isNaN(Number(value))) {\n            return str + \"[\" + value + \"]\";\n          }\n\n          if (str) {\n            return str + \".\" + value;\n          }\n\n          return value;\n        }, '');\n        toReturn[key] = flatObject[x];\n      }\n    } else {\n      toReturn[i] = obj[i];\n    }\n  }\n\n  return toReturn;\n}\nexport var isValidationError = function isValidationError(obj) {\n  return obj.message && obj.args;\n};\nexport function isObjectEmpty(obj) {\n  if (!obj) {\n    return true;\n  }\n\n  return Object.entries(obj).length === 0 && obj.constructor === Object;\n}\nexport default {\n  resetSubmitErrors: resetSubmitErrors\n};","map":null,"metadata":{},"sourceType":"module"}