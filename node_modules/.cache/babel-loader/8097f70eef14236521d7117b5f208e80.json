{"ast":null,"code":"var __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n}; // List of properties we expect in the options\n\n\nvar OptionsProperties = ['action', 'fetch', 'meta', 'onFailure', 'onSuccess', 'undoable', 'mutationMode', 'enabled'];\n\nvar isDataProviderOptions = function isDataProviderOptions(value) {\n  if (typeof value === 'undefined') return [];\n  var options = value;\n  return Object.keys(options).some(function (key) {\n    return OptionsProperties.includes(key);\n  });\n}; // As all dataProvider methods do not have the same signature, we must differentiate\n// standard methods which have the (resource, params, options) signature\n// from the custom ones\n\n\nexport var getDataProviderCallArguments = function getDataProviderCallArguments(args) {\n  var lastArg = args[args.length - 1];\n\n  var allArguments = __spreadArrays(args);\n\n  var resource;\n  var payload;\n  var options;\n\n  if (isDataProviderOptions(lastArg)) {\n    options = lastArg;\n    allArguments = allArguments.slice(0, args.length - 1);\n  }\n\n  if (typeof allArguments[0] === 'string') {\n    resource = allArguments[0];\n    payload = allArguments[1];\n  }\n\n  return {\n    resource: resource,\n    payload: payload,\n    allArguments: allArguments,\n    options: options\n  };\n};","map":null,"metadata":{},"sourceType":"module"}