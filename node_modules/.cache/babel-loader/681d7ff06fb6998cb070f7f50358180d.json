{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { FETCH_END, REFRESH_VIEW } from '../../../../actions';\nimport { GET_LIST, CREATE, DELETE, DELETE_MANY, UPDATE, UPDATE_MANY } from '../../../../core';\nimport ids from './cachedRequests/ids';\nimport total from './cachedRequests/total';\nimport validity from './cachedRequests/validity';\nvar initialState = {};\nvar initialSubstate = {\n  ids: [],\n  total: null,\n  validity: null\n};\n\nvar cachedRequestsReducer = function cachedRequestsReducer(previousState, action) {\n  var _a;\n\n  var _b;\n\n  if (previousState === void 0) {\n    previousState = initialState;\n  }\n\n  if (action.type === REFRESH_VIEW) {\n    if ((_b = action.payload) === null || _b === void 0 ? void 0 : _b.hard) {\n      // force refresh\n      return initialState;\n    } else {\n      // remove validity only\n      var newState_1 = {};\n      Object.keys(previousState).forEach(function (key) {\n        newState_1[key] = __assign(__assign({}, previousState[key]), {\n          validity: undefined\n        });\n      });\n      return newState_1;\n    }\n  }\n\n  if (action.meta && action.meta.optimistic) {\n    if (action.meta.fetch === CREATE || action.meta.fetch === DELETE || action.meta.fetch === DELETE_MANY || action.meta.fetch === UPDATE || action.meta.fetch === UPDATE_MANY) {\n      // force refresh of all lists because we don't know where the\n      // new/deleted/updated record(s) will appear in the list\n      return initialState;\n    }\n  }\n\n  if (!action.meta || action.meta.fetchStatus !== FETCH_END) {\n    // not a return from the dataProvider\n    return previousState;\n  }\n\n  if (action.meta.fetchResponse === CREATE || action.meta.fetchResponse === DELETE || action.meta.fetchResponse === DELETE_MANY || action.meta.fetchResponse === UPDATE || action.meta.fetchResponse === UPDATE_MANY) {\n    // force refresh of all lists because we don't know where the\n    // new/deleted/updated record(s) will appear in the list\n    return initialState;\n  }\n\n  if (action.meta.fetchResponse !== GET_LIST || action.meta.fromCache) {\n    // looks like a GET_MANY, a GET_ONE, or a cached response\n    return previousState;\n  }\n\n  var requestKey = JSON.stringify(action.requestPayload);\n  var previousSubState = previousState[requestKey] || initialSubstate;\n  return __assign(__assign({}, previousState), (_a = {}, _a[requestKey] = {\n    ids: ids(previousSubState.ids, action),\n    total: total(previousSubState.total, action),\n    validity: validity(previousSubState.validity, action)\n  }, _a));\n};\n\nexport default cachedRequestsReducer;","map":null,"metadata":{},"sourceType":"module"}