{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport * as React from 'react';\nimport { useRef, useCallback, useEffect, useMemo } from 'react';\nimport { Form } from 'react-final-form';\nimport arrayMutators from 'final-form-arrays';\nimport useInitializeFormWithRecord from './useInitializeFormWithRecord';\nimport useWarnWhenUnsavedChanges from './useWarnWhenUnsavedChanges';\nimport useResetSubmitErrors from './useResetSubmitErrors';\nimport sanitizeEmptyValues from './sanitizeEmptyValues';\nimport getFormInitialValues from './getFormInitialValues';\nimport { useDispatch } from 'react-redux';\nimport { setAutomaticRefresh } from '../actions/uiActions';\nimport { FormContextProvider } from './FormContextProvider';\nimport submitErrorsMutators from './submitErrorsMutators';\n/**\r\n * Wrapper around react-final-form's Form to handle redirection on submit,\r\n * legacy defaultValue prop, and array inputs.\r\n *\r\n * Requires a render function, just like react-final-form\r\n *\r\n * @example\r\n *\r\n * const SimpleForm = props => (\r\n *    <FormWithRedirect\r\n *        {...props}\r\n *        render={formProps => <SimpleFormView {...formProps} />}\r\n *    />\r\n * );\r\n *\r\n * @typedef {Object} Props the props you can use (other props are injected by Create or Edit)\r\n * @prop {Object} initialValues\r\n * @prop {Function} validate\r\n * @prop {Function} save\r\n * @prop {boolean} submitOnEnter\r\n * @prop {string} redirect\r\n * @prop {boolean} sanitizeEmptyValues\r\n *\r\n * @param {Props} props\r\n */\n\nvar FormWithRedirect = function FormWithRedirect(_a) {\n  var debug = _a.debug,\n      decorators = _a.decorators,\n      defaultValue = _a.defaultValue,\n      destroyOnUnregister = _a.destroyOnUnregister,\n      form = _a.form,\n      initialValues = _a.initialValues,\n      initialValuesEqual = _a.initialValuesEqual,\n      _b = _a.keepDirtyOnReinitialize,\n      keepDirtyOnReinitialize = _b === void 0 ? true : _b,\n      _c = _a.mutators,\n      mutators = _c === void 0 ? defaultMutators : _c,\n      record = _a.record,\n      _render = _a.render,\n      save = _a.save,\n      saving = _a.saving,\n      _d = _a.subscription,\n      subscription = _d === void 0 ? defaultSubscription : _d,\n      validate = _a.validate,\n      validateOnBlur = _a.validateOnBlur,\n      version = _a.version,\n      warnWhenUnsavedChanges = _a.warnWhenUnsavedChanges,\n      _e = _a.sanitizeEmptyValues,\n      shouldSanitizeEmptyValues = _e === void 0 ? true : _e,\n      props = __rest(_a, [\"debug\", \"decorators\", \"defaultValue\", \"destroyOnUnregister\", \"form\", \"initialValues\", \"initialValuesEqual\", \"keepDirtyOnReinitialize\", \"mutators\", \"record\", \"render\", \"save\", \"saving\", \"subscription\", \"validate\", \"validateOnBlur\", \"version\", \"warnWhenUnsavedChanges\", \"sanitizeEmptyValues\"]);\n\n  var redirect = useRef(props.redirect);\n  var onSave = useRef(save);\n  var formGroups = useRef({});\n  var finalMutators = useMemo(function () {\n    return mutators === defaultMutators ? mutators : __assign(__assign({}, defaultMutators), mutators);\n  }, [mutators]); // We don't use state here for two reasons:\n  // 1. There no way to execute code only after the state has been updated\n  // 2. We don't want the form to rerender when redirect is changed\n\n  var setRedirect = function setRedirect(newRedirect) {\n    redirect.current = newRedirect;\n  };\n  /**\r\n   * A form can have several Save buttons. In case the user clicks on\r\n   * a Save button with a custom onSave handler, then on a second Save button\r\n   * without custom onSave handler, the user expects the default save\r\n   * handler (the one of the Form) to be called.\r\n   * That's why the SaveButton onClick calls setOnSave() with no parameters\r\n   * if it has no custom onSave, and why this function forces a default to\r\n   * save.\r\n   */\n\n\n  var setOnSave = useCallback(function (newOnSave) {\n    typeof newOnSave === 'function' ? onSave.current = newOnSave : onSave.current = save;\n  }, [save]);\n  var formContextValue = useMemo(function () {\n    return {\n      setOnSave: setOnSave,\n      getGroupFields: function getGroupFields(name) {\n        return formGroups.current[name] || [];\n      },\n      registerGroup: function registerGroup(name) {\n        formGroups.current[name] = formGroups.current[name] || [];\n      },\n      unregisterGroup: function unregisterGroup(name) {\n        delete formGroups[name];\n      },\n      registerField: function registerField(source, group) {\n        if (group) {\n          var fields = new Set(formGroups.current[group] || []);\n          fields.add(source);\n          formGroups.current[group] = Array.from(fields);\n        }\n      },\n      unregisterField: function unregisterField(source, group) {\n        if (group) {\n          if (!formGroups.current[group]) {\n            console.warn(\"Invalid form group \" + group);\n          } else {\n            var fields = new Set(formGroups.current[group]);\n            fields.delete(source);\n            formGroups.current[group] = Array.from(fields);\n          }\n        }\n      }\n    };\n  }, [setOnSave]);\n  var finalInitialValues = useMemo(function () {\n    return getFormInitialValues(initialValues, defaultValue, record);\n  }, [JSON.stringify({\n    initialValues: initialValues,\n    defaultValue: defaultValue,\n    record: record\n  })]); // eslint-disable-line\n\n  var submit = function submit(values) {\n    var finalRedirect = typeof redirect.current === undefined ? props.redirect : redirect.current;\n\n    if (shouldSanitizeEmptyValues) {\n      var sanitizedValues = sanitizeEmptyValues(finalInitialValues, values);\n      return onSave.current(sanitizedValues, finalRedirect);\n    } else {\n      return onSave.current(values, finalRedirect);\n    }\n  };\n\n  return React.createElement(FormContextProvider, {\n    value: formContextValue\n  }, React.createElement(Form, {\n    key: version,\n    debug: debug,\n    decorators: decorators,\n    destroyOnUnregister: destroyOnUnregister,\n    form: form,\n    initialValues: finalInitialValues,\n    initialValuesEqual: initialValuesEqual,\n    keepDirtyOnReinitialize: keepDirtyOnReinitialize,\n    mutators: finalMutators,\n    onSubmit: submit,\n    subscription: subscription,\n    validate: validate,\n    validateOnBlur: validateOnBlur,\n    render: function render(formProps) {\n      return (// @ts-ignore Ignored because of a weird error about the active prop\n        React.createElement(FormView, __assign({}, props, formProps, {\n          record: record,\n          setRedirect: setRedirect,\n          saving: formProps.submitting || saving,\n          render: _render,\n          save: save,\n          warnWhenUnsavedChanges: warnWhenUnsavedChanges\n        }))\n      );\n    }\n  }));\n};\n\nvar defaultMutators = __assign(__assign({}, arrayMutators), submitErrorsMutators);\n\nvar defaultSubscription = {\n  submitting: true,\n  pristine: true,\n  valid: true,\n  invalid: true,\n  validating: true\n};\n\nvar FormView = function FormView(_a) {\n  var render = _a.render,\n      warnWhenUnsavedChanges = _a.warnWhenUnsavedChanges,\n      setRedirect = _a.setRedirect,\n      props = __rest(_a, [\"render\", \"warnWhenUnsavedChanges\", \"setRedirect\"]); // if record changes (after a getOne success or a refresh), the form must be updated\n\n\n  useInitializeFormWithRecord(props.record);\n  useWarnWhenUnsavedChanges(warnWhenUnsavedChanges);\n  useResetSubmitErrors();\n  var dispatch = useDispatch();\n  useEffect(function () {\n    dispatch(setAutomaticRefresh(props.pristine));\n  }, [dispatch, props.pristine]);\n  var redirect = props.redirect,\n      handleSubmit = props.handleSubmit;\n  /**\r\n   * We want to let developers define the redirection target from inside the form,\r\n   * e.g. in a <SaveButton redirect=\"list\" />.\r\n   * This callback does two things: handle submit, and change the redirection target.\r\n   * The actual redirection is done in save(), passed by the main controller.\r\n   *\r\n   * If the redirection target doesn't depend on the button clicked, it's a\r\n   * better option to define it directly on the Form component. In that case,\r\n   * using handleSubmit() instead of handleSubmitWithRedirect is fine.\r\n   *\r\n   * @example\r\n   *\r\n   * <Button onClick={() => handleSubmitWithRedirect('edit')}>\r\n   *     Save and edit\r\n   * </Button>\r\n   */\n\n  var handleSubmitWithRedirect = useCallback(function (redirectTo) {\n    if (redirectTo === void 0) {\n      redirectTo = redirect;\n    }\n\n    setRedirect(redirectTo);\n    handleSubmit();\n  }, [setRedirect, redirect, handleSubmit]);\n  return render(__assign(__assign({}, props), {\n    handleSubmitWithRedirect: handleSubmitWithRedirect\n  }));\n};\n\nexport default FormWithRedirect;","map":null,"metadata":{},"sourceType":"module"}