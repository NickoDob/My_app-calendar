{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n};\n\nimport { useCallback, useMemo } from 'react';\nimport ReactDOM from 'react-dom';\nimport { useSelector } from 'react-redux';\nimport { createSelector } from 'reselect';\nimport debounce from 'lodash/debounce';\nimport union from 'lodash/union';\nimport isEqual from 'lodash/isEqual';\nimport get from 'lodash/get';\nimport { CRUD_GET_MANY } from '../actions/dataActions/crudGetMany';\nimport { useSafeSetState } from '../util/hooks';\nimport useDataProvider from './useDataProvider';\nimport { useEffect } from 'react';\nimport { useVersion } from '../controller';\nvar queriesToCall = {};\nvar dataProvider;\nvar DataProviderOptions = {\n  action: CRUD_GET_MANY\n};\n/**\r\n * Call the dataProvider.getMany() method and return the resolved result\r\n * as well as the loading state.\r\n *\r\n * The return value updates according to the request state:\r\n *\r\n * - start: { loading: true, loaded: false, refetch }\r\n * - success: { data: [data from response], loading: false, loaded: true, refetch }\r\n * - error: { error: [error from response], loading: false, loaded: false, refetch }\r\n *\r\n * This hook will return the cached result when called a second time\r\n * with the same parameters, until the response arrives.\r\n *\r\n * This hook aggregates and deduplicates calls to the same resource, so for instance, if an app calls:\r\n *\r\n * useGetMany('tags', [1, 2, 3]);\r\n * useGetMany('tags', [3, 4]);\r\n *\r\n * during the same tick, the hook will only call the dataProvider once with the following parameters:\r\n *\r\n * dataProvider(GET_MANY, 'tags', [1, 2, 3, 4])\r\n *\r\n * @param resource The resource name, e.g. 'posts'\r\n * @param ids The resource identifiers, e.g. [123, 456, 789]\r\n * @param {Object} options Options object to pass to the dataProvider.\r\n * @param {boolean} options.enabled Flag to conditionally run the query. If it's false, the query will not run\r\n * @param {Function} options.onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\r\n * @param {Function} options.onFailure Side effect function to be executed upon failure, e.g. { onFailure: error => notify(error.message) }\r\n *\r\n * @returns The current request state. Destructure as { data, error, loading, loaded, refetch }.\r\n *\r\n * @example\r\n *\r\n * import { useGetMany } from 'react-admin';\r\n *\r\n * const PostTags = ({ record }) => {\r\n *     const { data, loading, error } = useGetMany('tags', record.tagIds);\r\n *     if (loading) { return <Loading />; }\r\n *     if (error) { return <p>ERROR</p>; }\r\n *     return (\r\n *          <ul>\r\n *              {data.map(tag => (\r\n *                  <li key={tag.id}>{tag.name}</li>\r\n *              ))}\r\n *          </ul>\r\n *      );\r\n * };\r\n */\n\nvar useGetMany = function useGetMany(resource, ids, options) {\n  if (options === void 0) {\n    options = {\n      enabled: true\n    };\n  } // we can't use useQueryWithStore here because we're aggregating queries first\n  // therefore part of the useQueryWithStore logic will have to be repeated below\n\n\n  var selectMany = useMemo(makeGetManySelector, []);\n  var data = useSelector(function (state) {\n    return selectMany(state, resource, ids);\n  });\n  var version = useVersion(); // used to allow force reload\n  // used to force a refetch without relying on version\n  // which might trigger other queries as well\n\n  var _a = useSafeSetState(0),\n      innerVersion = _a[0],\n      setInnerVersion = _a[1];\n\n  var refetch = useCallback(function () {\n    setInnerVersion(function (prevInnerVersion) {\n      return prevInnerVersion + 1;\n    });\n  }, [setInnerVersion]);\n\n  var _b = useSafeSetState({\n    data: data,\n    error: null,\n    loading: ids.length !== 0,\n    loaded: data.length !== 0 && !data.includes(undefined),\n    refetch: refetch\n  }),\n      state = _b[0],\n      setState = _b[1];\n\n  if (!isEqual(state.data, data)) {\n    setState(__assign(__assign({}, state), {\n      data: data\n    }));\n  }\n\n  dataProvider = useDataProvider(); // not the best way to pass the dataProvider to a function outside the hook, but I couldn't find a better one\n\n  useEffect(function () {\n    if (options.enabled === false) {\n      return;\n    }\n\n    if (!queriesToCall[resource]) {\n      queriesToCall[resource] = [];\n    }\n    /**\r\n     * queriesToCall stores the queries to call under the following shape:\r\n     *\r\n     * {\r\n     *   'posts': [\r\n     *     { ids: [1, 2], setState }\r\n     *     { ids: [2, 3], setState, onSuccess }\r\n     *     { ids: [4, 5], setState }\r\n     *   ],\r\n     *   'comments': [\r\n     *     { ids: [345], setState, onFailure }\r\n     *   ]\r\n     * }\r\n     */\n\n\n    queriesToCall[resource] = queriesToCall[resource].concat({\n      ids: ids,\n      setState: setState,\n      onSuccess: options && options.onSuccess,\n      onFailure: options && options.onFailure\n    });\n    callQueries(); // debounced by lodash\n  },\n  /* eslint-disable react-hooks/exhaustive-deps */\n  [JSON.stringify({\n    resource: resource,\n    ids: ids,\n    options: options,\n    version: version,\n    innerVersion: innerVersion\n  }), dataProvider]\n  /* eslint-enable react-hooks/exhaustive-deps */\n  );\n  return state;\n};\n/**\r\n * Memoized selector for getting an array of resources based on an array of ids\r\n *\r\n * @see https://react-redux.js.org/next/api/hooks#using-memoizing-selectors\r\n */\n\n\nvar makeGetManySelector = function makeGetManySelector() {\n  return createSelector([function (state, resource) {\n    return get(state, ['admin', 'resources', resource, 'data']);\n  }, function (_, __, ids) {\n    return ids;\n  }], function (resourceData, ids) {\n    return resourceData ? ids.map(function (id) {\n      return resourceData[id];\n    }) : ids.map(function (id) {\n      return undefined;\n    });\n  });\n};\n/**\r\n * Call the dataProvider once per resource\r\n */\n\n\nvar callQueries = debounce(function () {\n  var resources = Object.keys(queriesToCall);\n  resources.forEach(function (resource) {\n    var queries = __spreadArrays(queriesToCall[resource]); // cloning to avoid side effects\n\n    /**\r\n     * Extract ids from queries, aggregate and deduplicate them\r\n     *\r\n     * @example from [[1, 2], [2, null, 3], [4, null]] to [1, 2, 3, 4]\r\n     */\n\n\n    var accumulatedIds = queries.reduce(function (acc, _a) {\n      var ids = _a.ids;\n      return union(acc, ids);\n    }, []) // concat + unique\n    .filter(function (v) {\n      return v != null && v !== '';\n    }); // remove null values\n\n    if (accumulatedIds.length === 0) {\n      // no need to call the data provider if all the ids are null\n      queries.forEach(function (_a) {\n        var ids = _a.ids,\n            setState = _a.setState,\n            onSuccess = _a.onSuccess;\n        setState({\n          data: emptyArray,\n          loading: false,\n          loaded: true\n        });\n\n        if (onSuccess) {\n          onSuccess({\n            data: emptyArray\n          });\n        }\n      });\n      return;\n    }\n\n    dataProvider.getMany(resource, {\n      ids: accumulatedIds\n    }, DataProviderOptions).then(function (response) {\n      // Forces batching, see https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973\n      return ReactDOM.unstable_batchedUpdates(function () {\n        return queries.forEach(function (_a) {\n          var ids = _a.ids,\n              setState = _a.setState,\n              onSuccess = _a.onSuccess;\n          setState(function (prevState) {\n            return __assign(__assign({}, prevState), {\n              error: null,\n              loading: false,\n              loaded: true\n            });\n          });\n\n          if (onSuccess) {\n            var subData = ids.map(function (id) {\n              return response.data.find(function (datum) {\n                return datum.id == id;\n              });\n            } // eslint-disable-line eqeqeq\n            );\n            onSuccess({\n              data: subData\n            });\n          }\n        });\n      });\n    }).catch(function (error) {\n      return ReactDOM.unstable_batchedUpdates(function () {\n        return queries.forEach(function (_a) {\n          var setState = _a.setState,\n              onFailure = _a.onFailure;\n          setState({\n            error: error,\n            loading: false,\n            loaded: false\n          });\n          onFailure && onFailure(error);\n        });\n      });\n    });\n    delete queriesToCall[resource];\n  });\n});\nvar emptyArray = [];\nexport default useGetMany;","map":null,"metadata":{},"sourceType":"module"}