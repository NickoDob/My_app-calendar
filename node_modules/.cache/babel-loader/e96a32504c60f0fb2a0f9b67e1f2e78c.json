{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport * as React from 'react';\nimport { Children, cloneElement, memo } from 'react';\nimport PropTypes from 'prop-types';\nimport classnames from 'classnames';\nimport get from 'lodash/get';\nimport { makeStyles } from '@material-ui/core/styles';\nimport { Typography } from '@material-ui/core';\nimport ErrorIcon from '@material-ui/icons/Error';\nimport { useSelector } from 'react-redux';\nimport { useReference, getResourceLinkPath, ResourceContextProvider, RecordContextProvider, useRecordContext } from 'ra-core';\nimport LinearProgress from '../layout/LinearProgress';\nimport Link from '../Link';\nimport sanitizeFieldRestProps from './sanitizeFieldRestProps';\nimport { fieldPropTypes } from './types';\n/**\n * Fetch reference record, and delegate rendering to child component.\n *\n * The reference prop should be the name of one of the <Resource> components\n * added as <Admin> child.\n *\n * @example\n * <ReferenceField label=\"User\" source=\"userId\" reference=\"users\">\n *     <TextField source=\"name\" />\n * </ReferenceField>\n *\n * @default\n * By default, includes a link to the <Edit> page of the related record\n * (`/users/:userId` in the previous example).\n *\n * Set the `link` prop to \"show\" to link to the <Show> page instead.\n *\n * @example\n * <ReferenceField label=\"User\" source=\"userId\" reference=\"users\" link=\"show\">\n *     <TextField source=\"name\" />\n * </ReferenceField>\n *\n * @default\n * You can also prevent `<ReferenceField>` from adding link to children by setting\n * `link` to false.\n *\n * @example\n * <ReferenceField label=\"User\" source=\"userId\" reference=\"users\" link={false}>\n *     <TextField source=\"name\" />\n * </ReferenceField>\n *\n * @default\n * Alternatively, you can also pass a custom function to `link`. It must take reference and record\n * as arguments and return a string\n *\n * @example\n * <ReferenceField label=\"User\" source=\"userId\" reference=\"users\" link={(record, reference) => \"/path/to/${reference}/${record}\"}>\n *     <TextField source=\"name\" />\n * </ReferenceField>\n *\n * @default\n * In previous versions of React-Admin, the prop `linkType` was used. It is now deprecated and replaced with `link`. However\n * backward-compatibility is still kept\n */\n\nvar ReferenceField = function ReferenceField(props) {\n  var source = props.source,\n      emptyText = props.emptyText,\n      rest = __rest(props, [\"source\", \"emptyText\"]);\n\n  var record = useRecordContext(props);\n  var isReferenceDeclared = useSelector(function (state) {\n    return typeof state.admin.resources[props.reference] !== 'undefined';\n  });\n\n  if (!isReferenceDeclared) {\n    throw new Error(\"You must declare a <Resource name=\\\"\" + props.reference + \"\\\"> in order to use a <ReferenceField reference=\\\"\" + props.reference + \"\\\">\");\n  }\n\n  return get(record, source) == null ? emptyText ? React.createElement(Typography, {\n    component: \"span\",\n    variant: \"body2\"\n  }, emptyText) : null : React.createElement(NonEmptyReferenceField, __assign({}, rest, {\n    record: record,\n    source: source\n  }));\n};\n\nReferenceField.propTypes = {\n  addLabel: PropTypes.bool,\n  basePath: PropTypes.string,\n  children: PropTypes.element.isRequired,\n  classes: PropTypes.any,\n  className: PropTypes.string,\n  cellClassName: PropTypes.string,\n  headerClassName: PropTypes.string,\n  label: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),\n  record: PropTypes.any,\n  reference: PropTypes.string.isRequired,\n  resource: PropTypes.string,\n  sortBy: PropTypes.string,\n  sortByOrder: fieldPropTypes.sortByOrder,\n  source: PropTypes.string.isRequired,\n  translateChoice: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),\n  linkType: PropTypes.oneOfType([PropTypes.string, PropTypes.bool, PropTypes.func]),\n  link: PropTypes.oneOfType([PropTypes.string, PropTypes.bool, PropTypes.func]).isRequired\n};\nReferenceField.defaultProps = {\n  addLabel: true,\n  classes: {},\n  link: 'edit'\n};\n/**\n * This intermediate component is made necessary by the useReference hook,\n * which cannot be called conditionally when get(record, source) is empty.\n */\n\nexport var NonEmptyReferenceField = function NonEmptyReferenceField(_a) {\n  var children = _a.children,\n      record = _a.record,\n      source = _a.source,\n      props = __rest(_a, [\"children\", \"record\", \"source\"]);\n\n  if (React.Children.count(children) !== 1) {\n    throw new Error('<ReferenceField> only accepts a single child');\n  }\n\n  var basePath = props.basePath,\n      resource = props.resource,\n      reference = props.reference;\n  var resourceLinkPath = getResourceLinkPath(__assign(__assign({}, props), {\n    resource: resource,\n    record: record,\n    source: source,\n    basePath: basePath\n  }));\n  return React.createElement(ResourceContextProvider, {\n    value: reference\n  }, React.createElement(PureReferenceFieldView, __assign({}, props, useReference({\n    reference: reference,\n    id: get(record, source)\n  }), {\n    resourceLinkPath: resourceLinkPath\n  }), children));\n};\nvar useStyles = makeStyles(function (theme) {\n  return {\n    link: {\n      color: theme.palette.primary.main\n    }\n  };\n}, {\n  name: 'RaReferenceField'\n}); // useful to prevent click bubbling in a datagrid with rowClick\n\nvar stopPropagation = function stopPropagation(e) {\n  return e.stopPropagation();\n};\n\nexport var ReferenceFieldView = function ReferenceFieldView(props) {\n  var basePath = props.basePath,\n      children = props.children,\n      className = props.className,\n      classesOverride = props.classes,\n      error = props.error,\n      loaded = props.loaded,\n      loading = props.loading,\n      record = props.record,\n      reference = props.reference,\n      referenceRecord = props.referenceRecord,\n      refetch = props.refetch,\n      resource = props.resource,\n      resourceLinkPath = props.resourceLinkPath,\n      source = props.source,\n      _a = props.translateChoice,\n      translateChoice = _a === void 0 ? false : _a,\n      rest = __rest(props, [\"basePath\", \"children\", \"className\", \"classes\", \"error\", \"loaded\", \"loading\", \"record\", \"reference\", \"referenceRecord\", \"refetch\", \"resource\", \"resourceLinkPath\", \"source\", \"translateChoice\"]);\n\n  var classes = useStyles(props);\n\n  if (error) {\n    return (\n      /* eslint-disable jsx-a11y/role-supports-aria-props */\n      React.createElement(ErrorIcon, {\n        \"aria-errormessage\": error.message ? error.message : error,\n        role: \"presentation\",\n        color: \"error\",\n        fontSize: \"small\"\n      })\n      /* eslint-enable */\n\n    );\n  }\n\n  if (!loaded) {\n    return React.createElement(LinearProgress, null);\n  }\n\n  if (!referenceRecord) {\n    return null;\n  }\n\n  if (resourceLinkPath) {\n    return React.createElement(RecordContextProvider, {\n      value: referenceRecord\n    }, React.createElement(Link, {\n      to: resourceLinkPath,\n      className: className,\n      onClick: stopPropagation\n    }, cloneElement(Children.only(children), __assign({\n      className: classnames(children.props.className, classes.link // force color override for Typography components\n      ),\n      record: referenceRecord,\n      refetch: refetch,\n      resource: reference,\n      basePath: basePath,\n      translateChoice: translateChoice\n    }, sanitizeFieldRestProps(rest)))));\n  }\n\n  return React.createElement(RecordContextProvider, {\n    value: referenceRecord\n  }, cloneElement(Children.only(children), __assign({\n    record: referenceRecord,\n    resource: reference,\n    basePath: basePath,\n    translateChoice: translateChoice\n  }, sanitizeFieldRestProps(rest))));\n};\nReferenceFieldView.propTypes = {\n  basePath: PropTypes.string,\n  children: PropTypes.element,\n  className: PropTypes.string,\n  classes: PropTypes.any,\n  loading: PropTypes.bool,\n  record: PropTypes.any,\n  reference: PropTypes.string,\n  referenceRecord: PropTypes.any,\n  resource: PropTypes.string,\n  resourceLinkPath: PropTypes.oneOfType([PropTypes.string, PropTypes.oneOf([false])]),\n  source: PropTypes.string,\n  translateChoice: PropTypes.oneOfType([PropTypes.func, PropTypes.bool])\n};\nvar PureReferenceFieldView = memo(ReferenceFieldView);\nexport default ReferenceField;","map":null,"metadata":{},"sourceType":"module"}