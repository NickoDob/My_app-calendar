{"ast":null,"code":"import { useCallback, isValidElement } from 'react';\nimport set from 'lodash/set';\nimport useChoices from './useChoices';\nimport { useTranslate } from '../i18n';\n/*\n * Returns helper functions for suggestions handling.\n *\n * @param allowDuplicates A boolean indicating whether a suggestion can be added several times\n * @param allowEmpty A boolean indicating whether an empty suggestion should be added\n * @param choices An array of available choices\n * @param emptyText The text to use for the empty suggestion. Defaults to an empty string\n * @param emptyValue The value to use for the empty suggestion. Defaults to `null`\n * @param limitChoicesToValue A boolean indicating whether the initial suggestions should be limited to the currently selected one(s)\n * @param matchSuggestion Optional unless `optionText` is a React element. Function which check whether a choice matches a filter. Must return a boolean.\n * @param optionText Either a string defining the property to use to get the choice text, a function or a React element\n * @param optionValue The property to use to get the choice value\n * @param selectedItem The currently selected item. May be an array of selected items\n * @param suggestionLimit The maximum number of suggestions returned, excluding the empty one if `allowEmpty` is `true`\n * @param translateChoice A boolean indicating whether to option text should be translated\n *\n * @returns An object with helper functions:\n * - getChoiceText: Returns the choice text or a React element\n * - getChoiceValue: Returns the choice value\n * - getSuggestions: A function taking a filter value (string) and returning the matching suggestions\n */\n\nvar useSuggestions = function useSuggestions(_a) {\n  var allowCreate = _a.allowCreate,\n      allowDuplicates = _a.allowDuplicates,\n      allowEmpty = _a.allowEmpty,\n      choices = _a.choices,\n      _b = _a.createText,\n      createText = _b === void 0 ? 'ra.action.create' : _b,\n      _c = _a.createValue,\n      createValue = _c === void 0 ? '@@create' : _c,\n      _d = _a.emptyText,\n      emptyText = _d === void 0 ? '' : _d,\n      _e = _a.emptyValue,\n      emptyValue = _e === void 0 ? null : _e,\n      limitChoicesToValue = _a.limitChoicesToValue,\n      matchSuggestion = _a.matchSuggestion,\n      optionText = _a.optionText,\n      optionValue = _a.optionValue,\n      selectedItem = _a.selectedItem,\n      _f = _a.suggestionLimit,\n      suggestionLimit = _f === void 0 ? 0 : _f,\n      translateChoice = _a.translateChoice;\n  var translate = useTranslate();\n\n  var _g = useChoices({\n    optionText: optionText,\n    optionValue: optionValue,\n    translateChoice: translateChoice\n  }),\n      getChoiceText = _g.getChoiceText,\n      getChoiceValue = _g.getChoiceValue; // eslint-disable-next-line react-hooks/exhaustive-deps\n\n\n  var getSuggestions = useCallback(getSuggestionsFactory({\n    allowCreate: allowCreate,\n    allowDuplicates: allowDuplicates,\n    allowEmpty: allowEmpty,\n    choices: choices,\n    createText: createText,\n    createValue: createValue,\n    emptyText: translate(emptyText, {\n      _: emptyText\n    }),\n    emptyValue: emptyValue,\n    getChoiceText: getChoiceText,\n    getChoiceValue: getChoiceValue,\n    limitChoicesToValue: limitChoicesToValue,\n    matchSuggestion: matchSuggestion,\n    optionText: optionText,\n    optionValue: optionValue,\n    selectedItem: selectedItem,\n    suggestionLimit: suggestionLimit\n  }), [allowCreate, allowDuplicates, allowEmpty, choices, createText, createValue, emptyText, emptyValue, getChoiceText, getChoiceValue, limitChoicesToValue, matchSuggestion, optionText, optionValue, selectedItem, suggestionLimit, translate]);\n  return {\n    getChoiceText: getChoiceText,\n    getChoiceValue: getChoiceValue,\n    getSuggestions: getSuggestions\n  };\n};\n\nexport default useSuggestions;\n\nvar escapeRegExp = function escapeRegExp(value) {\n  return value ? value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') : '';\n}; // $& means the whole matched string\n\n/**\n * Default matcher implementation which check whether the suggestion text matches the filter.\n */\n\n\nvar defaultMatchSuggestion = function defaultMatchSuggestion(getChoiceText) {\n  return function (filter, suggestion, exact) {\n    if (exact === void 0) {\n      exact = false;\n    }\n\n    var suggestionText = getChoiceText(suggestion);\n    var isReactElement = isValidElement(suggestionText);\n    var regex = escapeRegExp(filter);\n    return isReactElement ? false : suggestionText && suggestionText.match( // We must escape any RegExp reserved characters to avoid errors\n    // For example, the filter might contains * which must be escaped as \\*\n    new RegExp(exact ? \"^\" + regex + \"$\" : regex, 'i'));\n  };\n};\n/**\n * Get the suggestions to display after applying a fuzzy search on the available choices\n *\n * @example\n *\n * getSuggestions({\n *   choices: [{ id: 1, name: 'admin' }, { id: 2, name: 'publisher' }],\n *   optionText: 'name',\n *   optionValue: 'id',\n *   getSuggestionText: choice => choice[optionText],\n * })('pub')\n *\n * // Will return [{ id: 2, name: 'publisher' }]\n * getSuggestions({\n *   choices: [{ id: 1, name: 'admin' }, { id: 2, name: 'publisher' }],\n *   optionText: 'name',\n *   optionValue: 'id',\n *   getSuggestionText: choice => choice[optionText],\n * })('pub')\n *\n * // Will return [{ id: 2, name: 'publisher' }]\n */\n\n\nexport var getSuggestionsFactory = function getSuggestionsFactory(_a) {\n  var _b = _a.allowCreate,\n      allowCreate = _b === void 0 ? false : _b,\n      _c = _a.allowDuplicates,\n      allowDuplicates = _c === void 0 ? false : _c,\n      _d = _a.allowEmpty,\n      allowEmpty = _d === void 0 ? false : _d,\n      _e = _a.choices,\n      choices = _e === void 0 ? [] : _e,\n      _f = _a.createText,\n      createText = _f === void 0 ? 'ra.action.create' : _f,\n      _g = _a.createValue,\n      createValue = _g === void 0 ? '@@create' : _g,\n      _h = _a.emptyText,\n      emptyText = _h === void 0 ? '' : _h,\n      _j = _a.emptyValue,\n      emptyValue = _j === void 0 ? null : _j,\n      _k = _a.optionText,\n      optionText = _k === void 0 ? 'name' : _k,\n      _l = _a.optionValue,\n      optionValue = _l === void 0 ? 'id' : _l,\n      getChoiceText = _a.getChoiceText,\n      getChoiceValue = _a.getChoiceValue,\n      _m = _a.limitChoicesToValue,\n      limitChoicesToValue = _m === void 0 ? false : _m,\n      _o = _a.matchSuggestion,\n      matchSuggestion = _o === void 0 ? defaultMatchSuggestion(getChoiceText) : _o,\n      selectedItem = _a.selectedItem,\n      _p = _a.suggestionLimit,\n      suggestionLimit = _p === void 0 ? 0 : _p;\n  return function (filter) {\n    var suggestions = []; // if an item is selected and matches the filter\n\n    if (selectedItem && !Array.isArray(selectedItem) && matchSuggestion(filter, selectedItem)) {\n      if (limitChoicesToValue) {\n        // display only the selected item\n        suggestions = choices.filter(function (choice) {\n          return getChoiceValue(choice) === getChoiceValue(selectedItem);\n        });\n      } else if (!allowDuplicates) {\n        // ignore the filter to show more choices\n        suggestions = removeAlreadySelectedSuggestions(choices, selectedItem, getChoiceValue);\n      } else {\n        suggestions = choices;\n      }\n    } else {\n      suggestions = choices.filter(function (choice) {\n        return matchSuggestion(filter, choice);\n      });\n\n      if (!allowDuplicates) {\n        suggestions = removeAlreadySelectedSuggestions(suggestions, selectedItem, getChoiceValue);\n      }\n    }\n\n    suggestions = limitSuggestions(suggestions, suggestionLimit);\n    var hasExactMatch = suggestions.some(function (suggestion) {\n      return matchSuggestion(filter, suggestion, true);\n    });\n\n    if (allowCreate) {\n      var filterIsSelectedItem = // If the selectedItem is an array (for example AutocompleteArrayInput)\n      // we should't try to match\n      !!selectedItem && !Array.isArray(selectedItem) ? matchSuggestion(filter, selectedItem, true) : false;\n\n      if (!hasExactMatch && !filterIsSelectedItem) {\n        suggestions.push(getSuggestion({\n          optionText: optionText,\n          optionValue: optionValue,\n          text: createText,\n          value: createValue\n        }));\n      }\n    }\n\n    if (allowEmpty) {\n      suggestions.unshift(getSuggestion({\n        optionText: optionText,\n        optionValue: optionValue,\n        text: emptyText,\n        value: emptyValue\n      }));\n    }\n\n    return suggestions;\n  };\n};\n/**\n * @example\n *\n * removeAlreadySelectedSuggestions(\n *  [{ id: 1, name: 'foo'}, { id: 2, name: 'bar' }],\n *  [{ id: 1, name: 'foo'}]\n * );\n *\n * // Will return [{ id: 2, name: 'bar' }]\n *\n * @param suggestions List of suggestions\n * @param selectedItems List of selection\n * @param getChoiceValue Converter function from suggestion to value\n */\n\nvar removeAlreadySelectedSuggestions = function removeAlreadySelectedSuggestions(suggestions, selectedItems, getChoiceValue) {\n  if (!selectedItems) {\n    return suggestions;\n  }\n\n  var selectedValues = Array.isArray(selectedItems) ? selectedItems.map(getChoiceValue) : [getChoiceValue(selectedItems)];\n  return suggestions.filter(function (suggestion) {\n    return !selectedValues.includes(getChoiceValue(suggestion));\n  });\n};\n/**\n * @example\n *\n * limitSuggestions(\n *  [{ id: 1, name: 'foo'}, { id: 2, name: 'bar' }],\n *  1\n * );\n *\n * // Will return [{ id: 1, name: 'foo' }]\n *\n * @param suggestions List of suggestions\n * @param limit\n */\n\n\nvar limitSuggestions = function limitSuggestions(suggestions, limit) {\n  if (limit === void 0) {\n    limit = 0;\n  }\n\n  return Number.isInteger(limit) && limit > 0 ? suggestions.slice(0, limit) : suggestions;\n};\n/**\n * addSuggestion(\n *  [{ id: 1, name: 'foo'}, { id: 2, name: 'bar' }],\n * );\n *\n * // Will return [{ id: null, name: '' }, { id: 1, name: 'foo' }, , { id: 2, name: 'bar' }]\n *\n * @param suggestions List of suggestions\n * @param options\n * @param options.optionText\n */\n\n\nvar getSuggestion = function getSuggestion(_a) {\n  var _b = _a.optionText,\n      optionText = _b === void 0 ? 'name' : _b,\n      _c = _a.optionValue,\n      optionValue = _c === void 0 ? 'id' : _c,\n      _d = _a.text,\n      text = _d === void 0 ? '' : _d,\n      _e = _a.value,\n      value = _e === void 0 ? null : _e;\n  var suggestion = {};\n  set(suggestion, optionValue, value);\n\n  if (typeof optionText === 'string') {\n    set(suggestion, optionText, text);\n  }\n\n  return suggestion;\n};","map":null,"metadata":{},"sourceType":"module"}